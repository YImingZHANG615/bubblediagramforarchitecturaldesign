<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>泡泡图编辑器</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body { display: flex; font-family: Arial, sans-serif; }
        #sidebar  { width: 300px; padding: 10px;background-color: #f0f0f0; border-right: 1px solid #636363; box-sizing: border-box; }
        #sidebar2 { width: 1000px; padding: 10px;background-color: #f0f0f0; border-right: 1px solid #636363; box-sizing: border-box; }
        #drag-handle { width: 10px; height: 100%; background-color: #000000; position:left; cursor: ew-resize; }
        #main-content { flex-grow: 1; flex-basis: calc(100% - 300px - 1000px); padding: 10px; }
        .form-group { margin-bottom: 10px; }
        label { display: block; margin-bottom: 5px; }
        input, select, button { width: 100%; padding: 5px; box-sizing: border-box; }
        button { margin-top: 5px; }
        #boundary-name { margin-top: 10px; }
        #chart { border: 1px solid #ccc; }
        .slider-group { margin-bottom: 10px; }
        .slider-group label { display: block; margin-bottom: 5px; }
        .boundary-handle { fill: rgb(120, 31, 31); cursor: pointer; }
        #vectorOutput { white-space: pre-wrap; background: #f9f9f9; padding: 10px; border: 1px solid #ccc; max-height: 200px; overflow-y: auto; }
        #floorPlanCanvas {
            border: 1px solid black;
            display: none; 
            margin-top: 10px;
            max-width: 100%; 
            height: auto;
        }
        .selected-link { background: #eef; }
        /* 修改部分开始 */
        .boundary-polygon {
            fill: none; /* 设置填充为透明 */
            stroke: #000; /* 设置边界线颜色 */
            stroke-width: 2px; /* 设置边界线宽度 */
        }
        #preview {
            max-width: 100%;
            max-height: 200px; /* 根据需要调整最大高度 */
            object-fit: contain; /* 保持图片比例 */
            display: none; /* 初始隐藏 */
        }
        /* 修改部分结束 */
    </style>
</head>
<body>
    <!-- 左栏: sidebar（节点编辑、边界设置等） -->
    <div id="sidebar">
        <!-- 选择节点 -->
        <details open>
            <summary>Node Selection<br>选择节点</summary>
            <div class="form-group">
                <label for="select-node-input">Node Name<br>节点名称</label>
                <input type="text" id="select-node-input" placeholder="输入节点名称">
                <button id="select-node-button">Select Node<br>选择节点</button>
            </div>

            <div id="node-info" style="display:none;">
                <div class="form-group">
                    <label for="node-name"> Name<br>名称</label>
                    <input type="text" id="node-name" placeholder="节点名称">
                </div>
                <div class="form-group">
                    <label for="node-radius"> Radius (mm)<br>半径(mm)</label>
                    <input type="number" id="node-radius" min="1">
                </div>
                <div class="form-group">
                    <label for="node-area">Area (m²)<br>面积(m²)</label>
                    <input type="number" id="node-area" step="0.000001" min="0">
                </div>
                <div class="form-group">
                    <label for="node-color">Color<br>Color<br>颜色</label>
                    <input type="color" id="node-color" value="#cccccc">
                </div>
                <div class="form-group">
                    <label>Connected Nodes<br>连接的节点:</label>
                    <div id="links-list"></div>
                    <button id="remove-selected-link" style="background:#e00; color:#fff;">Remove Selected Link<br>删除选中的连接</button>
                </div>
                <div id="link-edit-panel" style="display:none;">
                    <div class="form-group">
                        <label for="link-force-input">Link Strength<br>连接强度</label>
                        <input type="number" id="link-force-input" step="0.1" value="1">
                    </div>
                    <div class="form-group">
                        <label for="link-distance-input">Distance<br>距离</label>
                        <input type="number" id="link-distance-input" step="10" value="100">
                    </div>
                    <button id="update-link">Update Link<br>更新连接</button>
                </div>
                <div class="form-group">
                    <label for="new-link">Add Link To<br>添加链接到:</label>
                    <select id="new-link"></select>
                    <button id="add-link">Add Link<br>添加链接</button>
                </div>

                <div class="form-group">
                    <label>Segment Attraction<br>线段吸引</label>
                    <select id="line-segment-select"></select>
                    <input type="number" step="0.1" value="0" id="line-segment-attraction-input">
                    <button id="update-line-segment-attraction"> Set Attraction<br>设置吸引</button>
                </div>
                <button id="update-node">Update Node<br>更新节点</button>
                <button id="delete-node" style="background:#e00; color:#fff;">Delete Node<br>删除节点</button>
            </div>
            <p id="no-selection"> No Node Selected<br>未选择任何节点。点击节点(右键)或使用上方输入框选择。</p>
        </details>

        <!-- 创建新节点 -->
        <details open>
            <summary>Create New Node<br>创建新节点</summary>
            <div class="form-group">
                <label for="new-node-name"> Name<br>名称</label>
                <input type="text" id="new-node-name" placeholder="节点名称">
            </div>
            <div class="form-group">
                <label for="new-node-radius"> Radius (mm)<br>半径(mm)</label>
                <input type="number" id="new-node-radius" value="30" min="1">
            </div>
            <div class="form-group">
                <label for="new-node-area">Area (m²)<br>面积(m²)</label>
                <input type="number" id="new-node-area" step="0.000001" min="0">
            </div>
            <div class="form-group">
                <label for="new-node-color">Color<br>颜色</label>
                <input type="color" id="new-node-color" value="#cccccc">
            </div>
            <button id="create-node">Create Node<br>创建节点</button>
        </details>

        <!-- 全局颜色调整 -->
        <details open>
            <summary>Global Color Adjustment<br>全局颜色调整</summary>
            <div class="slider-group">
                <label>Hue Rotation (°)<br>色相旋转(°):<span id="hue-value">0</span></label>
                <input type="range" id="hue-slider" min="0" max="360" value="0">
                <label>Saturation Ratio<br>饱和度比例:<span id="sat-value">1</span></label>
                <input type="range" id="sat-slider" min="0" max="2" step="0.01" value="1">
                <label>Lightness Ratio<br>亮度比例:<span id="light-value">1</span></label>
                <input type="range" id="light-slider" min="0" max="2" step="0.01" value="1">
            </div>
        </details>

        <!-- 边界设置 -->
        <details open>
            <summary> Boundary Settings<br>边界设置</summary>
            <div class="form-group">
                <label for="boundary-type">Boundary Type<br>边界类型</label>
                <select id="boundary-type">
                    <option value="none"> None<br>无</option>
                    <option value="rectangle">Rectangle<br>矩形</option>
                    <option value="triangle">Triangle<br>三角形</option>
                </select>
                <button id="apply-boundary">Apply Boundary<br>应用边界</button>
                <div class="form-group">
                    <label>Sndary<br>how Bou显示边界 <input type="checkbox" id="show-boundary" checked></label>
                    <p id="boundary-name" style="display:none;">Boundary: Boundary1<br>边界: 边界1</p>
                    <p>Shift+Click to Add Vertex<br>Shift+点击空白处添加顶点，Shift+点击句柄移除顶点。</p>
                </div>
            </div>
        </details>
    </div>

    <!-- 中栏: main-content（泡泡图） -->
    <div id="main-content">
        <svg id="chart" width="1800" height="825">
            <g>
                <polygon class="boundary-polygon" style="display: none;"></polygon>
            </g>
            <!-- ... (保持原有内容不变) ... -->
        </svg>
    </div>

    <!-- 右栏: sidebar2（文件操作、图片上传转矢量、导入/导出Excel） -->
    <div id="sidebar2">
        <h2>村庄情况分析</h2>
        <iframe
            src="https://village-insights-generator.lovable.app/"
            width="900"
            height="500"
            style="border:0;"
            allowfullscreen=""
            loading="lazy">
        </iframe>
        <details open>
            <div id="drag-handle"></div>
                <p>Sidebar 2</p>
            <summary>File Operations<br>文件操作</summary>
            <button id="save-button"> Save JSON<br>保存JSON</button>
            <input type="file" id="load-file" style="display:none">
            <button id="load-button">Load JSON<br>加载JSON</button>
            <br><br>
            <button id="import-excel-button">Import Excel<br>导入Excel</button>
            <input type="file" id="excel-file-input" style="display:none" accept=".xlsx,.xls,.csv">
            <button id="export-excel-button">Export Excel<br>导出Excel</button>
        </details>

        <details open>
            <summary> Image Upload and Convert to Vector<br>图片上传并转换为矢量信息</summary>
            <input type="file" id="imageUpload" accept="image/*">
            <img id="preview" alt="预览">
            <div id="loading" style="display:none;">Processing...<br>正在处理...</div>
            <div id="vectorOutput"></div>
            <div id="error" style="color:red;"></div>
            <br>
            <!-- 一键复制JSON、生成平面图、下载平面图、Excel转换 等 -->
            <button id="copyJSONButton" style="display:none;">Copy JSON One Click<br>一键复制JSON</button>
            <button id="drawFloorPlanButton" style="display:none;">Generate Floor Plan<br>生成平面图</button>
            <button id="saveFloorPlanImage" style="display:none;">Download Floor Plan<br>下载平面图</button>
            <button id="excelFromVectorOutput" style="display:none;">Generate Excel One Click<br>一键生成Excel</button>
            <button id="visibilityAnalysisButton">Visibility Analysis<br>视域分析</button>
            <button id="roadfindButton">Road Find<br>两点寻路</button>
            <canvas id="floorPlanCanvas"></canvas>
            
            

        </details>
    </div>

    <!-- 引入 SheetJS & D3 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    
    <script>
    /** 
     * ========== 1. 常用颜色转换函数：hexToHSL & hslToHex ========== 
     */
    function hexToHSL(hex){
      let r = parseInt(hex.slice(1,3),16)/255;
      let g = parseInt(hex.slice(3,5),16)/255;
      let b = parseInt(hex.slice(5,7),16)/255;
      let max = Math.max(r,g,b), min = Math.min(r,g,b);
      let h, s, l = (max + min)/2;
      if(max === min){
        h = s = 0;
      } else {
        let d = max - min;
        s = (l>0.5) ? d/(2 - max - min) : d/(max + min);
        switch(max){
          case r: h = (g - b)/d + (g < b ? 6 : 0); break;
          case g: h = (b - r)/d + 2; break;
          case b: h = (r - g)/d + 4; break;
        }
        h *= 60;
      }
      return [h, s, l];
    }
    function hslToHex(h, s, l){
      h/=360;
      function hue2rgb(p,q,t){
        if(t<0) t+=1;
        if(t>1) t-=1;
        if(t<1/6) return p+(q-p)*6*t;
        if(t<1/2) return q;
        if(t<2/3) return p+(q-p)*(2/3-t)*6;
        return p;
      }
      let q = (l<0.5) ? (l*(1+s)) : (l+s-l*s);
      let p = 2*l - q;
      let rr = hue2rgb(p, q, h+1/3);
      let gg = hue2rgb(p, q, h);
      let bb = hue2rgb(p, q, h-1/3);
      return "#" + [rr,gg,bb].map(x=>Math.round(x*255).toString(16).padStart(2,'0')).join('');
    }

    const totalWidth=window.innerWidth;
    const totalHeight=window.innerHeight;
    // 两侧各300px => 中间宽度
    const width=totalWidth - 300 - 1000; 
    const height=totalHeight;

    const svg=d3.select("#chart")
        .attr("width", width)
        .attr("height", height);
    

   
    /**
     * ========== 2. 初始数据 + D3力导向 + 边界控制 + 全部逻辑 ==========
     */
    let nodesData = [
      { id:"护士台", label:"护士台", radius:140, color:"#20d920", lineAttractions:{} },
      { id:"治疗",   label:"治疗",   radius:80,  color:"#CCE5FF", lineAttractions:{} },
      { id:"谈话",   label:"谈话",   radius:50,  color:"#FFB266", lineAttractions:{} },
      { id:"处置",   label:"处置",   radius:90,  color:"#ff7575", lineAttractions:{} },
      { id:"医生办公", label:"医生办公", radius:90,color:"#0000cc", lineAttractions:{} },
      { id:"护士办公", label:"护士办公", radius:90,color:"#0000cc", lineAttractions:{} },
      { id:"换药",   label:"换药",   radius:90,  color:"#0000cc", lineAttractions:{} },
      { id:"会诊交班", label:"会诊交班",radius:90,color:"#0000cc", lineAttractions:{} },
      { id:"仪器",   label:"仪器",   radius:90,  color:"#808080", lineAttractions:{} },
      { id:"备餐",   label:"备餐",   radius:40,  color:"#808080", lineAttractions:{} },
      { id:"污洗",   label:"污洗",   radius:40,  color:"#808080", lineAttractions:{} },
      { id:"更衣女", label:"更衣女", radius:60,  color:"#808080", lineAttractions:{} },
      { id:"更衣男", label:"更衣男", radius:60,  color:"#808080", lineAttractions:{} },
      { id:"卫生间男", label:"卫生间男",radius:90,color:"#808080", lineAttractions:{} },
      { id:"卫生间女",label:"卫生间女",radius:90,color:"#808080", lineAttractions:{} },
      { id:"值班室男", label:"值班室男",radius:90,color:"#808080", lineAttractions:{} },
      { id:"值班室女", label:"值班室女",radius:90,color:"#808080", lineAttractions:{} },
      { id:"库房",   label:"库房",   radius:40,  color:"#808080", lineAttractions:{} },
      { id:"通讯室", label:"通讯室", radius:40,  color:"#7fa5e1", lineAttractions:{} }
    ];
    let linksData = [
      { source:"护士台", target:"护士办公", force:1, distance:200 },
      { source:"护士台", target:"治疗",     force:1, distance:200 },
      { source:"护士台", target:"处置",     force:1, distance:200 },
      { source:"处置",   target:"换药",     force:1, distance:400 },
      { source:"换药",   target:"治疗",     force:1, distance:400 },
      { source:"谈话",   target:"医生办公", force:1, distance:400 },
      { source:"护士台", target:"换药",     force:1, distance:200 },
      { source:"护士台", target:"备餐",     force:1, distance:200 },
      { source:"护士台", target:"会诊交班", force:1, distance:200 },
      { source:"护士办公",target:"值班室男", force:1, distance:400 },
      { source:"护士办公",target:"值班室女", force:1, distance:400 },
      { source:"医生办公",target:"处置",     force:1, distance:400 },
      { source:"医生办公",target:"换药",     force:1, distance:400 },
      { source:"医生办公",target:"治疗",     force:1, distance:400 },
      { source:"医生办公",target:"值班室男", force:1, distance:400 },
      { source:"医生办公",target:"值班室女", force:1, distance:400 },
      { source:"医生办公",target:"仪器",     force:1, distance:400 },
      { source:"治疗",   target:"仪器",     force:1, distance:400 },
      { source:"库房",   target:"仪器",     force:1, distance:400 },
      { source:"护士办公",target:"会诊交班", force:1, distance:400 },
      { source:"卫生间男",target:"卫生间女", force:1, distance:400 },
      { source:"卫生间男",target:"值班室男", force:1, distance:400 },
      { source:"卫生间男",target:"更衣男",   force:1, distance:400 },
      { source:"卫生间女",target:"更衣女",   force:1, distance:400 },
      { source:"值班室男",target:"更衣男",   force:1, distance:400 },
      { source:"更衣男",  target:"更衣女",   force:1, distance:400 },
      { source:"值班室女",target:"更衣女",   force:1, distance:400 },
      { source:"值班室男",target:"值班室女", force:1, distance:400 },
      { source:"值班室女",target:"卫生间女", force:1, distance:400 },
      { source:"备餐",   target:"污洗",     force:1, distance:400 },
      { source:"污洗",   target:"卫生间男", force:1, distance:400 },
      { source:"污洗",   target:"卫生间女", force:1, distance:400 },
      { source:"库房",   target:"值班室男", force:1, distance:400 },
      { source:"库房",   target:"值班室女", force:1, distance:400 },
      { source:"谈话",   target:"护士台",   force:1, distance:200 },
      { source:"通讯室", target:"值班室男", force:1, distance:400 }
    ];

    let chargeStrength=-100;
    let hueRotate=0, satScale=1, lightScale=1;
    let boundaryType='none', boundaryPoints=[], boundaryVisible=true, lineComponents=[];
    let centerStrength = 0.005;

    let boundaryGroup=svg.append("g");
    let boundaryPolygon=boundaryGroup.append("polygon")
      .attr("class","boundary-polygon")
      .style("display","none");
    let boundaryHandles=boundaryGroup.selectAll(".boundary-handle");

    function areaFromRadius(r_mm){
      return Math.PI*(r_mm*r_mm)/1e3;
    }
    function radiusFromArea(a_m2){
      return Math.sqrt((a_m2*1e3)/Math.PI);
    }

    let simulation=d3.forceSimulation(nodesData)
      .force("charge", d3.forceManyBody().strength(chargeStrength))
      .force("link", d3.forceLink(linksData).id(d=>d.id).distance(d=>d.distance))
      .force("collide", d3.forceCollide().radius(d=>d.radius+1))
      .force("center", d3.forceCenter(width/2, height/2).strength(centerStrength))
      .on("tick", ticked);

    /** link, node 初始绘制 */
    let link=svg.selectAll(".link")
      .data(linksData, d=>d.source.id+"-"+d.target.id)
      .enter().append("line")
      .attr("class","link")
      .attr("stroke","#999")
      .attr("stroke-opacity",0.6);

    let node=svg.selectAll(".node")
      .data(nodesData, d=>d.id)
      .enter().append("g")
      .attr("class","node")
      .on("contextmenu", function(event, d){
        event.preventDefault();
        nodeClicked(event, d);
      })
      .call(d3.drag()
        .on("start", dragStarted)
        .on("drag", dragged)
        .on("end", dragEnded)
      );

    node.append("circle")
      .attr("r", d=>d.radius)
      .attr("fill", d=>d.color)
      .attr("stroke","#333");

    node.append("text")
      .attr("text-anchor","middle")
      .attr("dy","-0.2em")
      .style("font-size","12px");

    node.append("text")
      .attr("text-anchor","middle")
      .attr("dy","1.2em")
      .style("font-size","10px")
      .style("fill","#333");

    /** Shift+点击空白处添加顶点 */
    svg.on("click", function(event){
      if(event.shiftKey && boundaryType!=='none'){
        let [mx,my] = d3.pointer(event);
        boundaryPoints.push([mx,my]);
        syncLineComponents();
        updateSimulation();
      }
    });

    function ticked(){
      if(boundaryVisible && boundaryType!=='none' && boundaryPoints.length>2){
        nodesData.forEach(d => keepNodeInsidePolygon(d, boundaryPoints));
      }
      applyLineSegmentAttraction();

      node.selectAll("circle").remove();
      node.selectAll("text").remove();

      node.each(function(d){
        // 转换颜色
        let [h,s,l] = hexToHSL(d.color);
        h = (h + hueRotate) % 360;
        s = Math.min(1, Math.max(0, s*satScale));
        l = Math.min(1, Math.max(0, l*lightScale));
        let adjColor = hslToHex(h, s, l);

        let sel=d3.select(this);
        sel.append("circle")
          .attr("r", d.radius)
          .attr("fill", adjColor)
          .attr("stroke","#333")
          .attr("stroke-width",1);

        let a_m2=areaFromRadius(d.radius);
        sel.append("text")
          .attr("text-anchor","middle")
          .attr("dy","-0.2em")
          .style("font-size","12px")
          .text(d.label);
        sel.append("text")
          .attr("text-anchor","middle")
          .attr("dy","1.2em")
          .style("font-size","10px")
          .style("fill","#333")
          .text("面积: "+a_m2.toFixed(3)+" m²");
      });

      let linkSel=svg.selectAll(".link").data(linksData, d=>(d.source.id||d.source)+"-"+(d.target.id||d.target));
      linkSel.exit().remove();
      linkSel.enter().append("line")
        .attr("class","link")
        .attr("stroke","#999")
        .attr("stroke-opacity",0.6)
        .merge(linkSel)
        .attr("x1", d=>d.source.x)
        .attr("y1", d=>d.source.y)
        .attr("x2", d=>d.target.x)
        .attr("y2", d=>d.target.y);

      let nodeSel=svg.selectAll(".node").data(nodesData, d=>d.id);
      nodeSel.exit().remove();
      let nodeEnter=nodeSel.enter().append("g")
        .attr("class","node")
        .on("contextmenu", function(event, d){
          event.preventDefault();
          nodeClicked(event, d);
        })
        .call(d3.drag()
          .on("start", dragStarted)
          .on("drag", dragged)
          .on("end", dragEnded)
        );
      node=nodeSel.merge(node);
      link=linkSel.merge(link);

      node.attr("transform", d => `translate(${d.x},${d.y})`);

      // 边界可见性
      if(!boundaryVisible || boundaryType==='none' || boundaryPoints.length<3){
        boundaryPolygon.style("display","none");
        boundaryHandles=boundaryHandles.data([]);
        boundaryHandles.exit().remove();
      } else {
        boundaryPolygon
          .style("display","block")
          .attr("points", boundaryPoints.map(p=>p.join(",")).join(" "));
        boundaryHandles=boundaryGroup.selectAll(".boundary-handle").data(boundaryPoints);
        boundaryHandles.exit().remove();
        let handleEnter=boundaryHandles.enter().append("circle")
          .attr("class","boundary-handle")
          .attr("r",6)
          .on("click",(event,d,i)=>{
            event.stopPropagation();
            // Shift+点击句柄 => 删除该顶点
            if(event.shiftKey && boundaryPoints.length>3){
              boundaryPoints.splice(i,1);
              syncLineComponents();
              updateSimulation();
            }
          })
          .call(d3.drag()
            .on("drag",(event,d)=>{
              d[0]=event.x; 
              d[1]=event.y;
              syncLineComponents();
              updateSimulation();
            })
          );
        boundaryHandles=handleEnter.merge(boundaryHandles)
          .attr("cx", d=>d[0])
          .attr("cy", d=>d[1]);
      }
    }

    function dragStarted(event,d){
      if(!event.active) simulation.alphaTarget(0.3).restart();
      d.fx=d.x; 
      d.fy=d.y;
    }
    function dragged(event,d){
      d.fx=event.x; 
      d.fy=event.y;
    }
    function dragEnded(event,d){
      if(!event.active) simulation.alphaTarget(0);
      d.fx=null; 
      d.fy=null;
    }
    function updateSimulation(){
      simulation.nodes(nodesData);
      simulation.force("link").links(linksData).distance(d=>d.distance);
      simulation.alpha(1).restart();
    }

    /** 应用/显示边界 */
    document.getElementById("apply-boundary").addEventListener("click",()=>{
      boundaryType=document.getElementById("boundary-type").value;
      if(boundaryType==='rectangle'){
        boundaryPoints = [
          [width*0.2, height*0.2],
          [width*0.8, height*0.2],
          [width*0.8, height*0.8],
          [width*0.2, height*0.8]
        ];
      } else if(boundaryType==='triangle'){
        boundaryPoints = [
          [width*0.5, height*0.2],
          [width*0.7, height*0.8],
          [width*0.3, height*0.8]
        ];
      } else {
        boundaryPoints=[];
      }
      boundaryVisible=(boundaryType!=='none');
      if(boundaryVisible){
        document.getElementById("boundary-name").style.display="block";
      } else {
        document.getElementById("boundary-name").style.display="none";
      }
      syncLineComponents();
      updateSimulation();
    });
    document.getElementById("show-boundary").addEventListener("change",(ev)=>{
      boundaryVisible=ev.target.checked;
      updateSimulation();
    });
    function syncLineComponents(){
      lineComponents=[];
      for(let i=0;i<boundaryPoints.length;i++){
        let j=(i+1)%boundaryPoints.length;
        lineComponents.push({
          id:"line"+i,
          p1:[boundaryPoints[i][0], boundaryPoints[i][1]],
          p2:[boundaryPoints[j][0], boundaryPoints[j][1]]
        });
      }
    }
    function pointInPolygon(x,y,poly){
      let inside=false;
      for(let i=0,j=poly.length-1;i<poly.length;j=i++){
        let xi=poly[i][0], yi=poly[i][1];
        let xj=poly[j][0], yj=poly[j][1];
        let intersect=((yi>y)!==(yj>y))&&(x<(xj-xi)*(y-yi)/(yj-yi)+xi);
        if(intersect) inside=!inside;
      }
      return inside;
    }
    function keepNodeInsidePolygon(d,poly){
      for(let iter=0;iter<3;iter++){
        if(pointInPolygon(d.x,d.y,poly)) return;
        let cx=d3.mean(poly,p=>p[0]);
        let cy=d3.mean(poly,p=>p[1]);
        d.x+=(cx-d.x)*0.1; 
        d.y+=(cy-d.y)*0.1;
      }
      if(!pointInPolygon(d.x,d.y,poly)){
        let [px,py]=projectToPolygon(d.x,d.y,poly);
        d.x=px; d.y=py;
      }
    }
    function projectToPolygon(x,y,poly){
      let minDist=Infinity, projX=x, projY=y;
      for(let i=0;i<poly.length;i++){
        let j=(i+1)%poly.length;
        let p=projectPointOnSegment(x,y,poly[i][0],poly[i][1],poly[j][0],poly[j][1]);
        let dist=Math.sqrt((p[0]-x)**2+(p[1]-y)**2);
        if(dist<minDist){
          minDist=dist; projX=p[0]; projY=p[1];
        }
      }
      return [projX,projY];
    }
    function projectPointOnSegment(px,py,x1,y1,x2,y2){
      let dx=x2-x1, dy=y2-y1;
      if(dx===0 && dy===0) return [x1,y1];
      let t=((px-x1)*dx+(py-y1)*dy)/(dx*dx+dy*dy);
      t=Math.max(0,Math.min(1,t));
      return [x1+t*dx,y1+t*dy];
    }

    /** 线段吸引(可忽略)
     */
     function applyLineSegmentAttraction(){
      nodesData.forEach(d=>{
        if(!d.lineAttractions)return;
        for(let segId in d.lineAttractions){
          let val=d.lineAttractions[segId];
          if(!val||val===0)continue;
          let seg=lineComponents.find(s=>s.id===segId);
          if(!seg)continue;
          let p=projectPointOnSegment(d.x,d.y,seg.p1[0],seg.p1[1],seg.p2[0],seg.p2[1]);
          d.x+=(p[0]-d.x)*0.01*val; 
          d.y+=(p[1]-d.y)*0.01*val;
        }
      });
    }

    /** 
     * ========== 3. 泡泡图: 节点/链接编辑、全局颜色 sliders ==========
     */
    let selectedNode=null, selectedLinkNodeId=null, editingLink=null;
    function nodeClicked(event,d){
      event.stopPropagation();
      showNodeInfo(d);
    }
    function showNodeInfo(d){
      selectedNode = d;
      document.getElementById("no-selection").style.display="none";
      document.getElementById("node-info").style.display="block";
      document.getElementById("node-name").value = d.label;
      document.getElementById("node-radius").value = d.radius;
      document.getElementById("node-area").value = areaFromRadius(d.radius).toFixed(6);
      document.getElementById("node-color").value = d.color;

      updateLinksList();
      updateNewLinkOptions();
      document.getElementById("link-edit-panel").style.display="none";

      updateLineSegmentOptions(d);
    }
    document.getElementById("select-node-button").addEventListener("click",()=>{
      const name=document.getElementById("select-node-input").value.trim();
      if(!name)return;
      const found=nodesData.find(n=>n.label===name);
      if(found) showNodeInfo(found);
      else alert("未找到名称="+name);
    });
    function updateLinksList(){
      let linksListDiv=document.getElementById("links-list");
      linksListDiv.innerHTML="";
      selectedLinkNodeId=null; editingLink=null;
      if(!selectedNode)return;
      let cLinks=linksData.filter(l=>l.source.id===selectedNode.id||l.target.id===selectedNode.id);
      cLinks.forEach(l=>{
        let otherId=(l.source.id===selectedNode.id)?l.target.id:l.source.id;
        let cnNode=nodesData.find(nd=>nd.id===otherId);
        let cnLabel=cnNode?cnNode.label:otherId;
        let div=document.createElement("div");
        div.textContent=cnLabel;
        div.addEventListener("click",()=>{
          [...linksListDiv.children].forEach(ch=>ch.classList.remove("selected-link"));
          div.classList.add("selected-link");
          selectedLinkNodeId=otherId; editingLink=l;
          document.getElementById("link-edit-panel").style.display="block";
          document.getElementById("link-force-input").value=l.force;
          document.getElementById("link-distance-input").value=l.distance;
        });
        linksListDiv.appendChild(div);
      });
    }
    document.getElementById("remove-selected-link").addEventListener("click",()=>{
      if(!selectedNode||!selectedLinkNodeId)return;
      linksData=linksData.filter(l=>!(
        (l.source.id===selectedNode.id&&l.target.id===selectedLinkNodeId)||
        (l.source.id===selectedLinkNodeId&&l.target.id===selectedNode.id)
      ));
      editingLink=null;
      document.getElementById("link-edit-panel").style.display="none";
      updateSimulation();
      updateLinksList();
      updateNewLinkOptions();
    });
    document.getElementById("update-link").addEventListener("click",()=>{
      if(!editingLink)return;
      editingLink.force=+document.getElementById("link-force-input").value;
      editingLink.distance=+document.getElementById("link-distance-input").value;
      updateSimulation();
    });
    function updateNewLinkOptions(){
      let newLinkSelect=document.getElementById("new-link");
      newLinkSelect.innerHTML="";
      if(!selectedNode)return;
      nodesData.forEach(nd=>{
        if(nd.id!==selectedNode.id && !linksData.find(l=>(
          (l.source.id===selectedNode.id&&l.target.id===nd.id)||
          (l.source.id===nd.id&&l.target.id===selectedNode.id)
        ))){
          let opt=document.createElement("option");
          opt.value=nd.id; 
          opt.text=nd.label;
          newLinkSelect.add(opt);
        }
      });
    }
    document.getElementById("add-link").addEventListener("click",()=>{
      if(!selectedNode) return;
      let newTgt=document.getElementById("new-link").value;
      if(!newTgt)return;
      linksData.push({ source:selectedNode.id, target:newTgt, force:1, distance:100});
      updateSimulation();
      updateLinksList();
      updateNewLinkOptions();
    });
    document.getElementById("update-node").addEventListener("click",()=>{
      if(!selectedNode) return;
      let newLabel=document.getElementById("node-name").value.trim();
      let newRadius=+document.getElementById("node-radius").value;
      let newArea=+document.getElementById("node-area").value;
      let newColor=document.getElementById("node-color").value;
      if(!isNaN(newArea)&&newArea>0){
        newRadius=radiusFromArea(newArea);
        document.getElementById("node-radius").value=Math.round(newRadius);
      }else{
        newArea=areaFromRadius(newRadius);
        document.getElementById("node-area").value=newArea.toFixed(6);
      }
      selectedNode.label=newLabel;
      selectedNode.radius=newRadius;
      selectedNode.color=newColor;
      updateSimulation();
    });
    document.getElementById("node-radius").addEventListener("input",()=>{
      let r=+document.getElementById("node-radius").value;
      if(r>0) document.getElementById("node-area").value=areaFromRadius(r).toFixed(6);
    });
    document.getElementById("node-area").addEventListener("input",()=>{
      let a=+document.getElementById("node-area").value;
      if(a>0){
        let r=radiusFromArea(a);
        document.getElementById("node-radius").value=Math.round(r);
      }
    });
    document.getElementById("delete-node").addEventListener("click",()=>{
      if(!selectedNode) return;
      nodesData=nodesData.filter(n=>n!==selectedNode);
      linksData=linksData.filter(l=>(l.source.id!==selectedNode.id&&l.target.id!==selectedNode.id));
      selectedNode=null; editingLink=null;
      document.getElementById("link-edit-panel").style.display="none";
      document.getElementById("node-info").style.display="none";
      document.getElementById("no-selection").style.display="block";
      updateSimulation();
    });

    document.getElementById("create-node").addEventListener("click",()=>{
      let newName = document.getElementById("new-node-name").value.trim();
      let newRadius = +document.getElementById("new-node-radius").value;
      let newArea = +document.getElementById("new-node-area").value;
      let newColor = document.getElementById("new-node-color").value;
      if (!newName) {
        alert("请提供名称。");
        return;
      }
      if (!isNaN(newArea) && newArea>0) {
        newRadius = radiusFromArea(newArea);
      }

      let newId = newName;
      let count=2;
      while(nodesData.find(nd=>nd.id===newId)) {
        newId = newName+"_"+count++;
      }
      nodesData.push({id:newId,label:newName,radius:newRadius>0?newRadius:30,color:newColor,lineAttractions:{}});
      updateSimulation();
    });

    document.getElementById("hue-slider").addEventListener("input",()=>{
      hueRotate=+document.getElementById("hue-slider").value;
      document.getElementById("hue-value").textContent=hueRotate;
      updateSimulation();
    });
    document.getElementById("sat-slider").addEventListener("input",()=>{
      satScale=+document.getElementById("sat-slider").value;
      document.getElementById("sat-value").textContent=satScale.toFixed(2);
      updateSimulation();
    });
    document.getElementById("light-slider").addEventListener("input",()=>{
      lightScale=+document.getElementById("light-slider").value;
      document.getElementById("light-value").textContent=lightScale.toFixed(2);
      updateSimulation();
    });
    function updateLineSegmentOptions(node){
      let select=document.getElementById("line-segment-select");
      select.innerHTML="";
      lineComponents.forEach(lc=>{
        let opt=document.createElement("option");
        opt.value=lc.id;
        opt.text=lc.id;
        select.add(opt);
      });
    }
    document.getElementById("update-line-segment-attraction").addEventListener("click",()=>{
      let segId=document.getElementById("line-segment-select").value;
      let val=+document.getElementById("line-segment-attraction-input").value;
      if(!selectedNode)return;
      selectedNode.lineAttractions[segId]=val;
      updateSimulation();
    });

    /** 
     * ========== 4. 文件操作(保存/加载JSON, 导入/导出Excel) 
     */
    document.getElementById("save-button").addEventListener("click",()=>{
      let dataToSave={
        nodes:nodesData,
        links:linksData.map(l => ({
          source:(l.source.id||l.source),
          target:(l.target.id||l.target),
          force:l.force,
          distance:l.distance
        })),
        boundaryType,
        boundaryPoints,
        lineComponents,
        hueRotate,
        satScale,
        lightScale
      };
      let blob=new Blob([JSON.stringify(dataToSave,null,2)],{type:"application/json"});
      let url=URL.createObjectURL(blob);
      let a=document.createElement("a");
      a.href=url;
      a.download="bubble_diagram.json";
      a.click();
      URL.revokeObjectURL(url);
    });
    document.getElementById("load-button").addEventListener("click",()=>{
      document.getElementById("load-file").click();
    });
    document.getElementById("load-file").addEventListener("change",(event)=>{
      let file=event.target.files[0];
      if(!file) return;
      let reader=new FileReader();
      reader.onload=(e)=>{
        try {
          let loaded=JSON.parse(e.target.result);
          nodesData=loaded.nodes||[];
          linksData=(loaded.links||[]).map(l=>({
            source:l.source,
            target:l.target,
            force:l.force,
            distance:l.distance
          }));
          boundaryType=loaded.boundaryType||'none';
          boundaryPoints=loaded.boundaryPoints||[];
          lineComponents=loaded.lineComponents||[];
          hueRotate=loaded.hueRotate||0;
          satScale=loaded.satScale||1;
          lightScale=loaded.lightScale||1;
          document.getElementById("boundary-type").value=boundaryType;
          if(boundaryType!=='none'){
            document.getElementById("boundary-name").style.display="block";
          } else {
            document.getElementById("boundary-name").style.display="none";
          }
          document.getElementById("hue-slider").value=hueRotate;
          document.getElementById("sat-slider").value=satScale;
          document.getElementById("light-slider").value=lightScale;
          document.getElementById("hue-value").textContent=hueRotate;
          document.getElementById("sat-value").textContent=satScale.toFixed(2);
          document.getElementById("light-value").textContent=lightScale.toFixed(2);
          updateSimulation();
        } catch(err) {
          alert("加载JSON失败，请检查文件格式。");
        }
      };
      reader.readAsText(file);
    });

    /** 导入 Excel: NxN邻接矩阵 => bubble图 */
    document.getElementById("import-excel-button").addEventListener("click",()=>{
      document.getElementById("excel-file-input").click();
    });
    document.getElementById("excel-file-input").addEventListener("change",(event)=>{
      let file=event.target.files[0];
      if(!file)return;
      let reader=new FileReader();
      reader.onload=(e)=>{
        try {
          let data=new Uint8Array(e.target.result);
          let wb=XLSX.read(data,{type:"array"});
          if(wb.SheetNames.length<2){
            alert("请确保Excel中存在sheet1(节点)和sheet2(邻接矩阵)");
            return;
          }
          let sheet1=wb.Sheets["sheet1"]||wb.Sheets[wb.SheetNames[0]];
          let sheet2=wb.Sheets["sheet2"]||wb.Sheets[wb.SheetNames[1]];
          if(!sheet1||!sheet2){
            alert("缺少sheet1或sheet2");
            return;
          }
          let nodeArr=XLSX.utils.sheet_to_json(sheet1,{header:1});
          let newNodesData=[];
          for(let i=1;i<nodeArr.length;i++){
            let row=nodeArr[i];
            if(!row||row.length<1)continue;
            let name=row[0], area=+row[1], color=row[2]||"#cccccc";
            if(!name)continue;
            let radius=30;
            if(area>0){
              radius=Math.round(Math.sqrt((area*1e3)/Math.PI));
            }
            newNodesData.push({id:name,label:name,radius,color,lineAttractions:{}});
          }

          let matrix=XLSX.utils.sheet_to_json(sheet2,{header:1});
          let headerRow=matrix[0];
          let nodeLabels=headerRow.slice(1);
          let newLinksData=[];
          for(let i=1;i<matrix.length;i++){
            let row=matrix[i];
            let rowLabel=row[0];
            let values=row.slice(1);
            for(let j=i;j<values.length;j++){
              let colLabel=nodeLabels[j];
              let val=values[j];
              if(val === "" || val === null || val === undefined) continue; // Skip empty cells
              let dist=+val;
              if(!isNaN(dist) && dist > 0){
                newLinksData.push({
                  source: rowLabel,
                  target: colLabel,
                  distance: dist,
                  force: 1
                });
              }
            }
          }

          nodesData=newNodesData;
          linksData=newLinksData;
          selectedNode=null; editingLink=null;
          document.getElementById("node-info").style.display="none";
          document.getElementById("no-selection").style.display="block";
          updateSimulation();
        } catch(err){
          alert("导入Excel失败，请检查文件格式。");
        }
      };
      reader.readAsArrayBuffer(file);
    });

    /** 导出 Excel(NxN) => bubble图，"公式+值" */
    document.getElementById("export-excel-button").addEventListener("click",()=>{
      try {
        const MAX_CAPACITY=300;
        let wb=XLSX.utils.book_new();

        // sheet1 => A列:Name, B列:Area, C列:Color
        let sheet1Data=[["Name","Area","Color"]];
        let roomInfos=[];
        nodesData.forEach((n,idx)=>{
          if(idx < MAX_CAPACITY){
            let area=Math.PI*(n.radius*n.radius)/1e3;
            sheet1Data.push([n.label, area.toFixed(2), n.color]);
            roomInfos.push({ name: n.label, id: n.id });
          }
        });
        // 若节点少于MAX_CAPACITY, 填充空行
        let usedRows=roomInfos.length;
        if(usedRows < MAX_CAPACITY){
          for(let r=usedRows; r<MAX_CAPACITY; r++){
            sheet1Data.push(["", "", ""]);
          }
        }
        let ws1=XLSX.utils.aoa_to_sheet(sheet1Data);

        XLSX.utils.book_append_sheet(wb,ws1,"sheet1");

        // sheet2 NxN => “公式 + 值”
        let sheet2Data=[];
        // 首行 => ['', =sheet1!A2, =sheet1!A3, ...]
        {
          let row0=[{ t:"s", v:"" }];
          for(let j=0; j<MAX_CAPACITY; j++){
            if(j < roomInfos.length){
              row0.push({
                t:"s",
                f:`=sheet1!A${j+2}`,
                v:roomInfos[j].name
              });
            } else {
              // 填充同步公式
              row0.push({
                t:"s",
                f:`=IF(sheet1!A${j+2}="", "", sheet1!A${j+2})`,
                v:""
              });
            }
          }
          sheet2Data.push(row0);
        }

        // 构建房间名到索引的映射
        let roomNameToIndex = {};
        roomInfos.forEach((room, idx) => {
          roomNameToIndex[room.name] = idx;
        });

        // adjacencyMap => 根据 walls 和 doors 判断连接，并使用实际的 distance 值
        let adjacencyMap = {};

        // 检查墙是否将两个房间连接
        linksData.forEach(l=>{
          let srcName = l.source.id || l.source;
          let tgtName = l.target.id || l.target;
          if(roomNameToIndex.hasOwnProperty(srcName) && roomNameToIndex.hasOwnProperty(tgtName)){
            let i = roomNameToIndex[srcName];
            let j = roomNameToIndex[tgtName];
            if(i < j){
              adjacencyMap[i+"___"+j]=l.distance; // 使用实际的 distance 值
            } else if(j < i){
              adjacencyMap[j+"___"+i]=l.distance;
            }
          }
        });

        // 后续行
        for(let i=0;i<MAX_CAPACITY;i++){
          let firstCell = { t:"s", v:"", f:"" };
          if(i < roomInfos.length){
            firstCell.f=`=sheet1!A${i+2}`;
            firstCell.v=roomInfos[i].name;
          } else {
            firstCell.f=`=IF(sheet1!A${i+2}="", "", sheet1!A${i+2})`;
            firstCell.v="";
          }
          let rowArr=[ firstCell ];
          for(let j=0;j<MAX_CAPACITY;j++){
            if(i >= roomInfos.length || j >= roomInfos.length){
              // 未定义房间的单元格设为空，保留上下三角的公式
              if(j > i){
                // 上三角: 空字符串
                rowArr.push({ t:"s", v: "", f:"" });
              } else if(j < i){
                // 下三角: 引用上三角对应单元格
                let refCell = XLSX.utils.encode_cell({ r:j + 1, c:i + 1 });
                rowArr.push({ t:"s", f: `=${refCell}`, v:"" });
              } else {
                // 对角线: 0
                rowArr.push({ t:"n", v:0 });
              }
              continue;
            }
            if(i === j){
              // 对角线 => 0
              rowArr.push({ t:"n", v:0 });
            } else if(i < j){
              // 上三角 => 根据 adjacencyMap 设置值，若无连接则 0
              let key = `${i}___${j}`;
              let val = adjacencyMap[key] || 0;
              rowArr.push({ t:"n", v: val });
            } else {
              // 下三角: 引用上三角对应单元格
              let refCell = XLSX.utils.encode_cell({ r:j + 1, c:i + 1 });
              rowArr.push({ t:"s", f: `=${refCell}`, v:"" });
            }
          }
          sheet2Data.push(rowArr);
        }

        let ws2=XLSX.utils.aoa_to_sheet(sheet2Data);
        
        // No additional action needed since already handled in loop above

        XLSX.utils.book_append_sheet(wb,ws2,"sheet2");

        // 写入文件
        let wbout=XLSX.write(wb,{bookType:"xlsx",type:"array"});
        let blob=new Blob([wbout],{type:"application/octet-stream"});
        let url=URL.createObjectURL(blob);
        let a=document.createElement("a");
        a.href=url;
        a.download="bubble_diagram_300.xlsx";
        a.click();
        URL.revokeObjectURL(url);
      } catch(e){
        console.error(e);
        alert("导出 Excel 失败，请检查数据格式。");
      }
    });

    /** rooms,walls,doors => NxN “公式+值” */
    document.getElementById('excelFromVectorOutput').addEventListener('click', () => {
        try{
            const jsonText = document.getElementById('vectorOutput').textContent.trim();
            if(!jsonText){
                alert("无可转换的 JSON。");
                return;
            }
            const data=JSON.parse(jsonText);
            if(!data.rooms || !data.walls || !data.doors){
                alert("JSON无效，需要包含rooms, walls, doors字段。");
                return;
            }

            const MAX_CAPACITY = 300;
            let wb = XLSX.utils.book_new();

            // sheet1 => A列:Name, B列:Area, C列:Color
            let sheet1Data = [["Name","Area","Color"]];
            let roomInfos = [];
            data.rooms.forEach((room, idx) => {
                if (idx >= MAX_CAPACITY) return; // 只处理前300个房间
                let rawArea = calculatePolygonArea(room);
                let area = rawArea/1500; // 使用真实面积
                let name = `Room ${idx + 1}`; // 或使用其他命名规则
                let color = "#ffffff"; // 默认颜色，可以根据需要调整
                sheet1Data.push([name, area.toFixed(2), color]);
                roomInfos.push({ name, id: name, coords: room }); // 添加coords以便后续使用
            });
            // 若房间少于MAX_CAPACITY => 补空行
            let used = roomInfos.length;
            if (used < MAX_CAPACITY) {
                for(let r=used; r<MAX_CAPACITY; r++){
                    sheet1Data.push(["", "", ""]);
                }
            }
            let ws1 = XLSX.utils.aoa_to_sheet(sheet1Data);
            XLSX.utils.book_append_sheet(wb, ws1, "sheet1");

            // sheet2 NxN => “公式+值”
            let sheet2Data = [];
            // 首行 => ['', =sheet1!A2, =sheet1!A3, ...]
            {
                let row0 = [{ t: "s", v: "" }];
                for (let j = 0; j < MAX_CAPACITY; j++) {
                    if (j < roomInfos.length) {
                        row0.push({
                            t: "s",
                            f: `=sheet1!A${j + 2}`,
                            v: roomInfos[j].name
                        });
                    } else {
                        // 填充同步公式
                        row0.push({
                            t: "s",
                            f: `=IF(sheet1!A${j + 2}="", "", sheet1!A${j + 2})`,
                            v: ""
                        });
                    }
                }
                sheet2Data.push(row0);
            }

            // 构建房间名到索引的映射
            let roomNameToIndex = {};
            roomInfos.forEach((room, idx) => {
                roomNameToIndex[room.name] = idx;
            });

            // adjacencyMap => 根据 walls 和 doors 判断连接，并使用实际的 distance 值
            let adjacencyMap = {};

            // 检查墙是否将两个房间连接
            data.walls.forEach(wall => {
                const [p1, p2] = wall.position;
                // 找到与 p1 近似的房间 A
                const roomA = roomInfos.find(room => room.coords.some(pt => arePointsClose([pt.x, pt.y], p1)));
                // 找到与 p2 近似的房间 B
                const roomB = roomInfos.find(room => room.coords.some(pt => arePointsClose([pt.x, pt.y], p2)));
                if(roomA && roomB){
                    let i = roomNameToIndex[roomA.name];
                    let j = roomNameToIndex[roomB.name];
                    if(i < j){
                        adjacencyMap[i+"___"+j] = wall.distance || 100; // 使用 wall.distance 或默认值
                    } else if(j < i){
                        adjacencyMap[j+"___"+i] = wall.distance || 100;
                    }
                }
            });

            // 检查门是否将两个房间连接
            data.doors.forEach(door => {
                const [p1, p2, p3, p4] = door.bbox;
                // 找到与 p1 近似的房间 A
                const roomA = roomInfos.find(room => room.coords.some(pt => arePointsClose([pt.x, pt.y], p1)));
                // 找到与 p3 近似的房间 B
                const roomB = roomInfos.find(room => room.coords.some(pt => arePointsClose([pt.x, pt.y], p3)));
                if(roomA && roomB){
                    let i = roomNameToIndex[roomA.name];
                    let j = roomNameToIndex[roomB.name];
                    if(i < j){
                        adjacencyMap[i+"___"+j] = 400; // 门连接的距离设为400
                    } else if(j < i){
                        adjacencyMap[j+"___"+i] = 400;
                    }
                }
            });

            // 后续行
            for(let i=0;i<MAX_CAPACITY;i++){
                let firstCell = { t: "s", v: "", f: "" };
                if(i < roomInfos.length){
                    firstCell.f = `=sheet1!A${i + 2}`;
                    firstCell.v = roomInfos[i].name;
                } else {
                    firstCell.f = `=IF(sheet1!A${i + 2}="", "", sheet1!A${i + 2})`;
                    firstCell.v = "";
                }
                let rowArr = [ firstCell ];
                for(let j=0;j<MAX_CAPACITY;j++){
                    if(i >= roomInfos.length || j >= roomInfos.length){
                        // 未定义房间的单元格设为空，保留上下三角的公式
                        if(j > i){
                            // 上三角: 空字符串
                            rowArr.push({ t: "s", v: "", f: "" });
                        } else if(j < i){
                            // 下三角: 引用上三角对应单元格
                            let refCell = XLSX.utils.encode_cell({ r:j + 1, c:i + 1 });
                            rowArr.push({ t: "s", f: `=${refCell}`, v: "" });
                        } else {
                            // 对角线: 0
                            rowArr.push({ t: "n", v:0 });
                        }
                        continue;
                    }
                    if(i === j){
                        // 对角线 => 0
                        rowArr.push({ t: "n", v:0 });
                    } else if(i < j){
                        // 上三角 => 根据 adjacencyMap 设置值，若无连接则 0
                        let key = `${i}___${j}`;
                        let val = adjacencyMap[key] || 0;
                        rowArr.push({ t: "n", v: val });
                    } else {
                        // 下三角 => 引用上三角对应单元格
                        let refCell = XLSX.utils.encode_cell({ r:j + 1, c:i + 1 });
                        rowArr.push({ t: "s", f: `=${refCell}`, v: "" });
                    }
                }
                sheet2Data.push(rowArr);
            }

            let ws2=XLSX.utils.aoa_to_sheet(sheet2Data);
            
            // No additional action needed since already handled in loop above

            XLSX.utils.book_append_sheet(wb,ws2,"sheet2");

            // 写入文件
            let wbout=XLSX.write(wb,{bookType:"xlsx",type:"array"});
            let blob=new Blob([wbout],{type:"application/octet-stream"});
            let url=URL.createObjectURL(blob);
            let a=document.createElement("a");
            a.href=url;
            a.download="bubble_diagram_300.xlsx";
            a.click();
            URL.revokeObjectURL(url);
        } catch(e){
            console.error(e);
            alert("导出 Excel 失败，请检查数据格式。");
        }
    });

    /** 
     * ========== 5. 矢量化API + 平面图绘制 + JSON->Excel(rooms,walls,doors) 
     */
    document.getElementById('imageUpload').addEventListener('change', function(event){
      let file=event.target.files[0];
      if(!file){
        alert("请上传一张图片。");
        return;
      }

      // 禁用上传按钮，防止在加载过程中再次上传
      const uploadButton = event.target;
      uploadButton.disabled = true;

      let reader=new FileReader();
      reader.onload=function(e){
        let dataURL=e.target.result;
        let base64Image=dataURL.split(',')[1];
        document.getElementById('preview').src=dataURL;
        document.getElementById('preview').style.display='block';
        sendToAPI(base64Image);
      };
      reader.onerror = function(e){
          alert("读取图片文件时出错。请重试。");
          uploadButton.disabled = false; // 重新启用按钮
      };
      reader.readAsDataURL(file);
    });
    function sendToAPI(base64Image){
      document.getElementById('loading').style.display='block';
      document.getElementById('vectorOutput').textContent='';
      document.getElementById('error').textContent='';
      document.getElementById('copyJSONButton').style.display='none';
      document.getElementById('drawFloorPlanButton').style.display='none';
      document.getElementById('saveFloorPlanImage').style.display='none';
      document.getElementById('excelFromVectorOutput').style.display='none';
      document.getElementById('visibilityAnalysisButton').style.display='none';
      document.getElementById('roadfindButton').style.display='none';
      
      const data=JSON.stringify({ image:base64Image });
      const xhr=new XMLHttpRequest();
      xhr.withCredentials=true;
      // 设置超时时间为30秒
      xhr.timeout = 30000; // 30,000毫秒
      xhr.addEventListener('readystatechange',function(){
        if(this.readyState===this.DONE){
          document.getElementById('loading').style.display='none';
          // 重新启用上传按钮
          document.getElementById('imageUpload').disabled = false;
          if(this.status===200){
            try{
              const response=JSON.parse(this.responseText);
              document.getElementById('vectorOutput').textContent=JSON.stringify(response,null,2);
              document.getElementById('copyJSONButton').style.display='inline';
              document.getElementById('drawFloorPlanButton').style.display='inline';
              document.getElementById('saveFloorPlanImage').style.display='inline';
              document.getElementById('excelFromVectorOutput').style.display='inline';
              document.getElementById('visibilityAnalysisButton').style.display='inline';
              document.getElementById('roadfindButton').style.display='inline';

            }catch(err){
              document.getElementById('vectorOutput').textContent=this.responseText;
            }
          }else{
            document.getElementById('error').textContent=`错误 ${this.status}: ${this.statusText}\n${this.responseText}`;
          }
        }
      });
      // 处理超时
      xhr.addEventListener('timeout', function(){
        document.getElementById('loading').style.display='none';
        document.getElementById('error').textContent='请求超时，请检查网络连接或稍后重试。';
        document.getElementById('imageUpload').disabled = false; // 重新启用按钮
      });
      xhr.open('POST','https://floor-plan-digitalization.p.rapidapi.com/raster-to-vector-base64');
      xhr.setRequestHeader('x-rapidapi-key','e6b5e3a327msh44b190915a03adap1255fcjsndc6a009b5130'); // 请将 'YOUR_RAPIDAPI_KEY' 替换为您的 RapidAPI Key
      xhr.setRequestHeader('x-rapidapi-host','floor-plan-digitalization.p.rapidapi.com');
      xhr.setRequestHeader('Content-Type','application/json');
      xhr.send(data);
    }

    // 平面图绘制
    function drawFloorPlan(data){
        let bounding = getFloorPlanBoundingBox(data);
        let margin=50;
        let w=bounding.maxX - bounding.minX + margin*2;
        let h=bounding.maxY - bounding.minY + margin*2;
        const canvas=document.getElementById('floorPlanCanvas');
        const ctx=canvas.getContext('2d');
        canvas.width=Math.max(100, w);
        canvas.height=Math.max(10, h);

let offsetX=-bounding.minX+margin;
let offsetY=-bounding.minY+margin;

ctx.clearRect(0,0,canvas.width,canvas.height);

// walls
ctx.strokeStyle='black';
ctx.lineWidth=2;
(data.walls||[]).forEach(wall=>{
    const [start,end]=wall.position;
    ctx.beginPath();
    ctx.moveTo(start[0]+offsetX, start[1]+offsetY);
    ctx.lineTo(end[0]+offsetX, end[1]+offsetY);
    ctx.stroke();
});

// doors
ctx.fillStyle='brown';
(data.doors||[]).forEach(door=>{
    const [p1,p2,p3,p4]=door.bbox;
    ctx.beginPath();
    ctx.moveTo(p1[0]+offsetX, p1[1]+offsetY);
    ctx.lineTo(p2[0]+offsetX, p2[1]+offsetY);
    ctx.lineTo(p3[0]+offsetX, p3[1]+offsetY);
    ctx.lineTo(p4[0]+offsetX, p4[1]+offsetY);
    ctx.closePath();
    ctx.fill();
});

// rooms
ctx.fillStyle='rgba(0,255,0,0.3)';
(data.rooms||[]).forEach(room=>{
    ctx.beginPath();
    room.forEach((pt,idx)=>{
        if(idx===0){
            ctx.moveTo(pt.x+offsetX, pt.y+offsetY);
        } else {
            ctx.lineTo(pt.x+offsetX, pt.y+offsetY);
        }
    });
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
});

canvas.style.display='block';
}

// 计算多边形面积的函数（Shoelace Formula）
function calculatePolygonArea(coords) {
let n = coords.length;
let area = 0;
for (let i = 0; i < n; i++) {
    let j = (i + 1) % n;
    area += coords[i].x * coords[j].y - coords[j].x * coords[i].y;
}
return Math.abs(area / 2);
}

// 判断两点是否接近（用于墙、门的判断）
function arePointsClose(p1, p2, tolerance = 5) {
return Math.abs(p1[0] - p2[0]) <= tolerance && Math.abs(p1[1] - p2[1]) <= tolerance;
}

function getFloorPlanBoundingBox(data){
let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
(data.walls||[]).forEach(w=>{
    const [s,e]=w.position;
    minX=Math.min(minX,s[0],e[0]);
    maxX=Math.max(maxX,s[0],e[0]);
    minY=Math.min(minY,s[1],e[1]);
    maxY=Math.max(maxY,s[1],e[1]);
});
(data.doors||[]).forEach(d=>{
    const [p1,p2,p3,p4]=d.bbox;
    [p1,p2,p3,p4].forEach(pt=>{
        minX=Math.min(minX,pt[0]);
        maxX=Math.max(maxX,pt[0]);
        minY=Math.min(minY,pt[1]);
        maxY=Math.max(maxY,pt[1]);
    });
});
(data.rooms||[]).forEach(r=>{
    r.forEach(pt=>{
        minX=Math.min(minX,pt.x);
        maxX=Math.max(maxX,pt.x);
        minY=Math.min(minY,pt.y);
        maxY=Math.max(maxY,pt.y);
    });
});
return {minX, maxX, minY, maxY};
}

/** 
* ========== 5. 矢量化API + 平面图绘制 + JSON->Excel(rooms,walls,doors) 
*/
// 复制 JSON
document.getElementById('copyJSONButton').addEventListener('click', () => {
const jsonText = document.getElementById('vectorOutput').textContent;
navigator.clipboard.writeText(jsonText).then(() => {
    alert("JSON 已复制到剪贴板！");
}).catch(err => {
    alert("复制失败：" + err);
});
});

// 生成平面图按钮
document.getElementById('drawFloorPlanButton').addEventListener('click', () => {
try{
    const jsonText = document.getElementById('vectorOutput').textContent.trim();
    if(!jsonText){
        alert("无可转换的 JSON。");
        return;
    }
    const data=JSON.parse(jsonText);
    drawFloorPlan(data);
} catch(e){
    alert("生成平面图失败，请检查 JSON 格式。");
}
});

// 下载平面图
document.getElementById('saveFloorPlanImage').addEventListener('click', () => {
const canvas = document.getElementById('floorPlanCanvas');
if(canvas.style.display === 'none'){
    alert("请先生成平面图。");
    return;
}
const link = document.createElement('a');
link.download = 'floor_plan.png';
link.href = canvas.toDataURL();
link.click();
});
// 添加视域分析按钮点击事件
document.getElementById('visibilityAnalysisButton').addEventListener("click", () => {
// 创建一个包含当前页面 URL 的参数
const currentUrl = window.location.href;
const params = new URLSearchParams({ returnUrl: currentUrl });
window.location.href = `视域分析.html?${params.toString()}`;
});
// 添加路径分析按钮点击事件
document.getElementById('roadfindButton').addEventListener("click", () => {
// 创建一个包含当前页面 URL 的参数
const currentUrl = window.location.href;
const params = new URLSearchParams({ returnUrl: currentUrl });
window.location.href = `寻路带沙盘导出.html?${params.toString()}`;
});
</script>
<script>
// 
</script>
</html>
